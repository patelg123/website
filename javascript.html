<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap  CDN files -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

	<!-- my style sheets-->
	<link rel="stylesheet" href="style/main.css">
	<script src="scripts/functions.js"></script>

</head>
<body id="myPage" data-spy="scroll" data-target=".navbar" data-offset="60">


<!-- Nav Bar -->
<nav id="navbar" class="navbar navbar-default navbar-fixed-top">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
				<span class="icon-bar"></span>
        		<span class="icon-bar"></span>
        		<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand left" href="#"><img src="images/images_small.png" /></a>
		</div>
		<div class="collapse navbar-collapse" id="myNavbar">
			<ul class="nav navbar-nav navbar-right">
				<li><a href="index.html"><span class="glyphicon glyphicon-home"> Home</span></a></li>
				<li><a href="about_me.html"><span class="glyphicon glyphicon-user"> About Me</span></a></li>
				<li><a href="javascript.html">JavaScript</a></li>
				<!--
					<li><img class="img-responsive" alt="css logo"  width="10%" height="10%" src="images/css_icon.png" /><a href="#css">Style</a></li>
					<li><a href="#blog">Blog</a></li>
				-->
			</ul>
		</div>
	</div>
</nav>


<div class="jumbotron text-center">
	<h1>JavaScript</h1>
</div>


<!--JavaScript Arrays container-->
<div id="javascript_array_operations" class="container-fluid text-center">

	<div class="row content">
		<div class="col-sm-2 sidenav">

		</div>

		<div class="col-sm-8 text-left">

			<h1>Array Operations</h1>

			<h3>push()</h3>
			<p>Adds new items to the end of an array.</p>
			<pre>
var arr = [1,2,3];
arr.push(4);
// arr is now [1,2,3,4]
			</pre>

			<h3>pop()</h3>
			<p>Removes the last element of an array.</p>
			<pre>
var arr = [1, 4, 6].pop();
// array becomes [1, 4]
			</pre>

			<h3>shift()</h3>
			<p>Removes first item of an array.</p>
			<pre>
var oneDown = [1, 4, 6].shift();
// array becomes [4, 6]
			</pre>

			<h3>unshift()</h3>
			<p>Adds items to the beginning of an array.</p>
			<pre>
var arr = [1,2,3];
arr.unshift(4);
// arr is now [4, 1, 2, 3]
			</pre>

			<h3>forEach()</h3>
			<p>Calls a provided function once for each element in an array, in order.</p>
			<pre>
var colors = ['red','blue','green'];

function print(val){
	console.log(val);
}

colors.forEach(print);

//red
//blue
//green
			</pre>

			<h3>map()</h3>
			<p>Calls a provided function once for each element in an array, in order, creating a new array </p>
			<pre>
var colors = ['red','blue','green'];

function capitalize(val){
	return val.toUpperCase();
}

var capitalizedColors = colors.map(capitalize);

//["RED", "GREEN, "BLUE"]
			</pre>

			<h3>filter()</h3>
			<p>Creates an array filled with all array elements that pass a test (provided as a function).</p>
			<pre>
var value = [1, 60, 34, 30, 20, 5]

function lessThan20(val){
	return val < 20;

}

var valueLessThan20 = values.filter(lessThan20);

//[1, 5]
			</pre>

			<h3>find()</h3>
			<p>Returns the value of the first element in an array that passes a test (provided as a function).</p>
			<pre>
var ages = [3, 10, 18, 20];

function checkAdult(age) {
    return age >= 18;
}

var firstAdult = ages.find(checkAdult);
//18
			</pre>

			<h3>every()</h3>
			<p>Checks if all elements in an array passes a test (provided as a function) and returns <i>true</i> or <i>false</i></p>
			<pre>
var ages = [32, 33, 16, 40];

function checkAdult(age) {
    return age >= 18;
}

console.log(ages.every(checkAdult));

//false
			</pre>

			<h3>some()</h3>
			<p>Checks if any of the elements in an array passes a test (provided as a function) and returns <i>true</i> or <i>false</i></p>
			<pre>
var ages = [3, 10, 18, 20];

function checkAdult(age) {
    return age >= 18;
}

console.log(ages.some(checkAdult));

//true
			</pre>

			<h3>reduce()</h3>
			<p>Executes a provided function for each value of the array and reduces the array to a single value.</p>
			<pre>
var numbers = [65, 44, 12, 4];

function getSum(total, num) {
    return total + num;
}

console.log(ages.reduce(getSum));

//125
			</pre>


		</div>

		<div class="col-sm-2 sidenav">

		</div>


	</div>
</div>

<!--
<div id="javascript_es6_classes" class="container-fluid text-center">

	<div class="row content">
		<div class="col-sm-2 sidenav">

		</div>

		<div class="col-sm-8 text-left">


        </div>



    <div class="col-sm-2 sidenav">

    </div>
</div>

-->

<div id="javascript_es6_arrow_function" class="container-fluid text-center">

	<div class="row content">
		<div class="col-sm-2 sidenav">

		</div>

		<div class="col-sm-8 text-left">

            <h1>ES6 Arrow Functions</h1>

            <h3>Introduction</h3>
            <p>
                Two factors influenced the introduction of arrow functions: shorter function syntax and non-binding of this. It is important to note that
                arrow functions cannot be used as constructors as other functions can.
            </P>

            <h3>Shorter Function Syntax</h3>

            <p>Consider the following function</p>
            <pre>
function funcName(param1, param2) {
   return param1 + param2;
 }

funcName(2, 2);
// returns 4

            </pre>
            <p>Using the new arrow function syntax, it can now be written in the following way:</p>

            <pre>
var funcName = (param1, param2) => { param1 + param2 };

funcName(2, 2);
// returns 4
            </pre>

            <p>If a function has only one parameter, the parenthesis are optional:</p>

            <pre>
function funcName(param1) {
   return param1 + 2;
 }

funcName(2);
// returns 4

// With arrow function:
var funcName = param1 => { param1 + 2 };

funcName(2);
// returns 4

// It can also be written like the following as we are returning an expression:
var funcName = param1 => param1 + 2 ;

funcName(2);
//returns 4

            </pre>

            <p>The paramter list for a function with no parameters shouldbe written with a pair of parenthesis:</p>

            <pre>
() => { statements };
            </pre>

            <P>The body of the function should be parenthesized if it is returning an object literal expression</p>
            <pre>
params => ({foo: bar});
            </pre>


            <h3>No Binding Of This</h3>

            <p>
                An arrow function does not bind 'this'. Arrows instead bind `this` to the immediate enclosing lexical scope
                Therefore, you donâ€™t need bind() or that = this, anymore.
                <br /><br />
                Consider the following, in non-strict mode, the growUp() function defines `this` as the global object, which is different from the `this` defined by the Person() constructor.
                In strict mode, this is undefined.
            </p>

            <pre>
function Person() {
  // The Person() constructor defines `this` as an instance of itself.
  this.age = 0;

  setInterval(function growUp() {
    this.age++;
    console.log(this.age)
  }, 1000);
}

var p = new Person();
// The above will return NaN every 1000 milliseconds because
// the growUp() function defines `this` as the global object

            </pre>

            <p>In ECMAScript 3/5, the this issue was fixable by assigning the value in this to a variable that could be closed over.</p>

            <pre>
function Person() {
  var that = this;
  that.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `that` variable of which
    // the value is the expected object.
    that.age++;
    console.log(that.age);
  }, 1000);
}

var p = new Person();
// The above will return a number incremented by 1 every second.

            </pre>

            <p>
                An arrow function does not have its own this; the this value of the enclosing execution context is used.
                Thus, in the following code, the this within the function that is passed to setInterval has the same value as this in the enclosing function:
            </p>

            <pre>
function Person(){
  this.age = 0;

  setInterval(() => {
    this.age++; // |this| properly refers to the person object
    console.log(this.age);
  }, 1000);
}

var p = new Person();
// The above will return a number incremented by 1 every second.

            </pre>



        </div>

    </div>

    <div class="col-sm-2 sidenav">

    </div>
</div>




<div id="javascript_es6_classes" class="container-fluid text-center">

	<div class="row content">
		<div class="col-sm-2 sidenav">

		</div>

		<div class="col-sm-8 text-left">

			<h1>ES6 Classes</h1>

            <h3>Introduction</h3>

            <p>
                It is important to note that JavaScript's 'Class' syntax in ES6 is little more than syntactic 'sugar over' for the existing prototype based behaviour.
                It simply provides a more convenient syntax for creating objects related via prototype linkage.
            </p>

            <p>
                JavaScript's "classes" aren't like classes in languages like Java pr Python. In these class based languages you create classes which are templates for objects.
                <br /><br />
                When you want a new object, you instantiate the class, which tells the language engine to copy the methods and properties of the class into a new entity, called an instance.
                The instance is your object, and, after instantiation, has absolutely no active relation with the parent class.
            </p>

            <p>
                "Instantiating" a class in JavaScript does create a new object, but not one that is independent of its parent class.
                Rather, it creates an object that is linked to a prototype. Changes to that prototype propagate to the new object, even after instantiation.
            </p>

            <h3>Example Of Using Class Syntax</h3>

            <pre>
"use strict";

// Food is a base class
class Food {
  constructor (name, protein, carbs, fat) {
    this.name = name;
    this.protein = protein;
    this.carbs = carbs;
    this.fat = fat;
  }

  toString () {
    return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`
  }

  print () {
    console.log( this.toString() );
  }
}

const chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);

chicken_breast.print(); // 'Chicken Breast | 26g P :: 0g C :: 3.5g F'

            </pre>

            <h3>Same thing using Constructor Function</h3>

            <pre>
function Food(name, protein, carbs, fat) {
  this.name = name;
  this.protein = protein;
  this.carbs = carbs;
  this.fat = fat;
}

Food.prototype.toString = function toString () {
        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`
}

Food.prototype.print = function print() {
      console.log( this.toString() );
}


const chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);

chicken_breast.print(); // 'Chicken Breast | 26g P :: 0g C :: 3.5g F'

          </pre>

          <h3>Inheritance Using New ES6 Syntax</h3>

          <p>
            With the new syntax, subclasses are created with 'extend' and calling with 'super'
          </p>

          <pre>
"use strict";

// Food is a base class
class Food {
    constructor (name, protein, carbs, fat) {
        this.name = name;
        this.protein = protein;
        this.carbs = carbs;
        this.fat = fat;
    }

    toString () {
        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`
    }

    print () {
      console.log( this.toString() );
    }
}

// FatFreeFood is a derived class
class FatFreeFood extends Food {
    constructor (name, protein, carbs) {
        super(name, protein, carbs, 0);
    }

    print () {
        super.print();
        console.log(`Would you look at that -- ${this.name} has no fat!`);
    }
}

const fat_free_yogurt = new FatFreeFood('Greek Yogurt', 16, 12);
fat_free_yogurt.print(); // 'Greek Yogurt | 26g P :: 16g C :: 0g F
                        //  Would you look at that -- Greek Yogurt has no fat!'

          </pre>

          <h3>The same thing pre ES6</h3>

          <pre>
function Food(name, protein, carbs, fat) {
        this.name = name;
        this.protein = protein;
        this.carbs = carbs;
        this.fat = fat;
}

Food.prototype.toString = function toString () {
        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`
}

Food.prototype.print = function print() {
      console.log( this.toString() );

}

function FatFreeFood (name, protein, carbs, fat) {
	Food.call(this, name, protein, carbs, fat);
}

FatFreeFood.prototype = Object.create(Food.prototype);

FatFreeFood.prototype.print_message = function print_message() {
	console.log(`Would you look at that -- ${this.name} has no fat!`);
}

const fat_free_yogurt = new FatFreeFood('Greek Yogurt', 16, 12);
fat_free_yogurt.print();
fat_free_yogurt.print_message(); // 'Greek Yogurt | 26g P :: 16g C :: 0g F
                                //  Would you look at that -- Greek Yogurt has no fat!'

          </pre>

        </div>



        <div class="col-sm-2 sidenav">

        </div>
  </div>
</div>




<footer class="container-fluid text-center">
 	<a href="#myPage" title="To Top"><span class="glyphicon glyphicon-chevron-up"></span></a>
</footer>



</body>


</html>
